# Inspecting internal CRuby structs  in Lldb

You can cast stuff in lldb, this is especially useful when looking at `VALUE`'s
(see [[ruby-object-lifecycle]])

Example: Let's take a look at the global object `argf` (which is something we
had to do recently when looking at a bug):

```
(lldb) p argf
(VALUE) $80 = 0x00000001018353b8
```

Because it's a VALUE, we can use `rp` (providing we configured `lldb` to import
the `lldb_cruby.py` helper script mentioned in [[lldb-tips]]).

```
(lldb) rp argf
T_DATA: (const char *) wrap_struct_name = 0x000000010033e302 "ARGF"
(struct RTypedData) $16 = {
  basic = (flags = 0x000000000000000c, klass = 0x0000000101043b78)
  type = 0x00000001003d4488
  typed_flag = 0x0000000000000001
  data = 0x0000000100823cd0
}
```

We can see that this is a `T_DATA` struct that's explosed to the Ruby layer as
the constant `ARGF`.

If we look at how `argf` is being used in the C. We can see that it's often used
as `ARGF` - which in MRI is a macro that takes the `RData` struct and converts
it to an `argf` struct

```
#define argf_of(obj) (*(struct argf *)DATA_PTR(obj))
#define ARGF argf_of(argf)
```

So, whilst me don't have any preprocessor directives in an `lldb` session, we
can do this conversion ourselves.

We can find out that `RDATA_PTR` is just a macro that expands to grab the
contents of the `data` member of the struct, like this:

```
#define DATA_PTR(obj)             RDATA(obj)->data
```

So. We can

1. cast `argf` to `RData`, allowing us to reference it's `data` member
2. cast the `VALUE` in the `data` member to a pointer to an `argf` struct (which
   is what `argf_of` is doing)
3. dereference the pointer to a `struct argf`. Because at this point, we're
   holding a struct rather than a pointer we can just use `p` to print it,
   rather than `rp` which will try and treat it as a `VALUE`

Altogether that looks like this:

```
(lldb) p *(struct argf *)((struct RTypedData *)argf)->data
(struct argf) $82 = {
  filename = 0x00000001018356d8
  current_file = 0x0000000000000008
  last_lineno = 1
  lineno = 0
  argv = 0x0000000101835408
  inplace = 0x000000010105a2d8
  encs = {
    enc = 0x0000000000000000
    enc2 = 0x0000000000000000
    ecflags = 0
    ecopts = 0x0000000000000000
  }
  init_p = '\0'
  next_p = '\0'
  binmode = '\0'
}
```

If we want to look at one of the members, we can assume it's a `VALUE` by
casting it and then using `rp` to dereference and print it.

```
(lldb) rp (VALUE)(*(struct argf *)((struct RTypedData *)argf)->data).inplace
T_STRING: [FROZEN] (const char [4]) $84 = ".bak"
```

However, if we back up a step and don't dereference the `struct argf *` then we
don't need to do the explicit value cast as `rp` will handle that for us. This
is probably safer as we're not having to do an explicit cast, also it's less
typing.

The following two expressions are equivalent (but the first is maybe better):

```
(lldb) rp ((struct argf *)((struct RTypedData *)argf)->data)->inplace
T_STRING: [FROZEN] (const char [4]) $93 = ".bak"
(lldb) rp (VALUE)(*(struct argf *)((struct RTypedData *)argf)->data).inplace
T_STRING: [FROZEN] (const char [4]) $95 = ".bak"
```

[//begin]: # "Autogenerated link references for markdown compatibility"
[ruby-object-lifecycle]: ruby-object-lifecycle "Ruby Object/GC Lifecycle"
[lldb-tips]: lldb-tips "Lldb Tips"
[//end]: # "Autogenerated link references"