# Walking the Heap

This function walks the heap - page at a time. The callback provided

- Reminder of what an `RVALUE` is: [[rvalue]]
- `each_obj_callback` is defined as follows:

  ```c
  typedef int each_obj_callback(void *, void *, size_t, void *);
  ```

  This is a function type, it defines a type named `each_obj_callback` that is a
  funtion with the signature `(void *, void *, size_t, void *)`

  `void *` is the void pointer, this is a pointer that can point to any data type.

  So. something of type `each_obj_callback` must be a function that takes 4
  arguments where the third is a `size_t` and the others can be anything.

  From the comments around this area (`gc.c:3133` or thereabouts). The arguments
  are as follows:

    1. `vstart` a pointer to the first living object of the heap page (so not a
       slot on the freelist?)
    2.  `vend` a pointer to the next valid heap page
    3.  `stride` a distance to the next value (this is normally `sizeof(RVALUE)`
        if you just want to walk one object at a time, I guess you could change
        this to jump any number of objects at a time, although I'm not sure why
        you would. I don't think you can jump dynamically, as this is just a
        standard `size_t`.
    4. `data` is a pointer to something. This is so you can collect some data out of the callback function and keep it somewhere -

  This means that these callback functions are

```c
// objspace - the struct that holds the heaps and bookkeeping information about them
// callback - our callback function ()
// data - don't know what this is used for yet.
static void
objspace_each_objects_without_setup(rb_objspace_t *objspace, each_obj_callback *callback, void *data)
{
    // basically an unsigned long long I think
    size_t i;
    // a pointer to a heap page object
    struct heap_page *page;
    // declare 2 RVALUE's objects pstart and pend. Initialize pstart to NULL
    RVALUE *pstart = NULL, *pend;

    i = 0;

    //heap allocated pages => the count of allocated pages stored in the objspace struct
    while (i < heap_allocated_pages) {

        //decrement the counter if
        //  - the counter is a positive integer AND
        //  - the starting page is lower than the previous page's starting address
        while (0 < i && pstart < heap_pages_sorted[i-1]->start)              i--;
        // increment the counter if
        //  - the counter is less than the count of allocated pages AND
        //  - the starting page is higher than
        while (i < heap_allocated_pages && heap_pages_sorted[i]->start <= pstart) i++;
        if (heap_allocated_pages <= i) break;

        page = heap_pages_sorted[i];

        pstart = page->start;
        pend = pstart + page->total_slots;

        if ((*callback)(pstart, pend, sizeof(RVALUE), data)) {
          break;
        }
    }
}
```

[//begin]: # "Autogenerated link references for markdown compatibility"
[rvalue]: rvalue "Rvalue"
[//end]: # "Autogenerated link references"